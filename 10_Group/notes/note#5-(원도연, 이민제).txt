cpp 8장 상속

객체지향은 재 사용성을 강조한다. 상속으로 재사용성을 높일 수 있다.

C++에서의 상속이란
	클래스 사이에서의 상속관계 정의
		객체 사이에는 상속 관계 없음
	기본 클래스의 속성과 기능을 파생 클래스에 물려주는것
		기본 클래스 - 상속해주는 클래스로 부모 클래스이다
		파생 클래스 - 상속받는 클래스로 자식 클래스이다
			파생클래스는 기본클래스의 속성과 기능을 물려받고 자신만의
			속성과 기능을 추가하여 작성한다
	기본 클래스에서 파생 클래스로 갈 수록 클래스의 개념이 구체화 된다
	다중 상속을 통한 클래스의 재활용성을 높임
	동적 바인딩

상속의 표현
	일반 전화기(전화기능) 무선전화기(스마트폰 이전의) 스마트폰이 있다고 할 때,
	무선 전화기는 일반 전화기의 전화 기능을 상속 받을 수 있고, 스마트폰은 무선 전화기의
	기능을 상속받아 일반 전화기능 또한 상속 받을 수 있다.
		다중상속

상속의 목적 및 장점
	간결한 클래스 작성
		기본 클래스의 기능을 물려받아 파생 클래스를 간결하게 작성
	클래스 간의 계층적 분류 및 관리의 용이함
		상속은 클래스들의 구조적 관계 파악에 용이
	클래스 재사용과 확장을 통한 소프트에어 생산성 향상
		빠른 소프트웨어 생산 필요
		기존에 작성한 클래스의 재사용 - 상속
			상속 받은 후 새로운 기능을 추가하여 확장
		앞으로 있을 상속에 대비한 클래스의 객체 지향적 설계 필요

상속 관계로 클래스의 간결화 사례에 대한 토론(페어 토론)
	각 클래스 글에 대한 기능들을 확인하고 간결화 된 표를 확인하며 토론을 나눔
	그러던 중 해당 수업자료에 나오는 간결화 된 표에 대한 공통적인 의문점에 대해 고민
		상속에 대한 연결의 화살표 방향이 그 기능을 자식에게 주는 것이니 아래로 향해야하지않나?
		이전 페이지인 5페이지에서도 전화기 상속에 대한 내용이 화살표가 자식에서 부모 클래스로
		향해 있음 이 의미에 대해서 한번 더 생각 자식클래스가 --> 여기 부모 클래스를 상속받았다
		라는 의미의 화살표로 이해하고 의문점에 대해 간략한 토론 마무리
	이후 재사용과 확장에 대한 이야기로 토론을 이어감

	교수님 설명
		각 4가지 클래스들에 중복되는 기능들을 먼저 확인한다. 말하기 걷기 등등 4가지가 나옴
		이 것을 먼저 최상위 클래스로 생성하기로 한다 그 다음 또 중복되는 기능들이 있는지 
		확인한다. 각각 두 클래스들이 기능들이 중복됨을 확인 이 때 최상위 클래스에서 각각 먼저
		상속을 받아 이어가는 방식으로 설계 함.		

클래스 상속과 객체
	상속 선언
		class Student:pulic Person {
			// Person을 상속받는 Student 선언
			...
		};
		class StudentWorker:public Student {
			// Student를 상속받는 StudentWorker선언
			...
		};
		
		Student 클래스는 Person 클래스의 멤버를 물려받는다.
		StudentWorker 클래스는 Student의 멤버를 물려받는다.
			Student가 물려받은 Person의 멤버도 함께 물려받는다.

예제 8-1 Point 클래스를 상속받는 ColorPoint 클래스 만들기
	실습진행

파생 클래스에서 기본 클래스 멤버 접근
	기본 클래스와 그에 대한 파생클래스가 있을 때 파생클래스에서 기본 클래스를 호출하는 식으로
	기본 클래스의 멤버에 접근할 수 있다.
	
외부에서 파생 클래스 객체에 대한 접근
	private로 생성된 변수를 제외하고는 기본클래스, 파생클래스 멤버들 호출 가능

상속과 객체 포인터 - 업 캐스팅
	업캐스팅
		파생 클래스 포인터가 기본 클래스 포인터에 치환되는 것
			ex) 사람을 동물로 봄
		
		Point* pBase = pDer;// 업 캐스팅 코드
		
		pDer포인터로 객체 cp의 모든 public 멤버에 접근 가능
		pBase 포인터로 기본 클래스의 public 멤버 접근 가능

	업 캐스팅은 생물을 가리키는 손가락으로 동물, 사람, 식물 등 생물의 속성을 받은 객체들을 
	가르키는것. 무생물은 가르키지 않는다.

상속과 객체 포인터 - 다운 캐스팅
	다운캐스팅
		기본 클래스의 포인터가 파생 클래스의 포인터에 치환되는 것
		
		Point* pBase = &cp;// 업캐스팅
		pDer = (ColorPoint*)pBase; //다운캐스팅
		
		pDer포인터로 객체 cp의 모든 public 멈버 접근 가능
		pBase포인터로 기본 클래스의 public 멤버만 접근 가능
protected 접근 지정
	접근 지정자
		private 멤버
			선언된 클래스 내에서만 접근 가능
			파생 클레스에서도 기본 클래스의 private멤버 직접 접근 불가
		public 멤버
			선언된 클래스나 외부 어떤 클래스, 모든 외부 함수에 접근 허용
			파생 클래스에서 기본 클래스의 public 멤버 접근 가능
		protected 멤버
			선언된 클래스에서 접근 가능
			파생 클래스에서만 접근 허용
				파생 클래스가 아닌 다른 클래스나 외부 함수에서는
				protected 멤버를 접근할 수 없다.
		private와 protected의 차이 프로텍티드는 파생클래스도 접근가능

멤버의 접근 지정에 따른 접근성
		코드를 통한 내용 교차 검증확인

상속과 생성자, 소멸자
	질문1: 파생클래스의 객체가 생성될 때 파생 클래스의 생성자와 기본 클래스의 생성자가 모두
	실행되는가? 아니면 파생 클래스의 생성자만 실행되는가?
		답: 둘 다 실행된다.
	질문2: 파생 클래스의 생성자와 기본 클래스의 생성자 중 어떤 생성자가 먼저 생성되는가?
		답: 기본 클래스의 생성자가 먼저 실행된 후 파생클래스의 생성자가 실행된다.
		
		위 내용을 종합하면 기본클래스의 생성자가 생성이 선행되어야 파생클래스가 그것을
		토대로 생성될 수 있기에 기본클래스가 먼저 생성되고 이후 파생클래스 생성으로
		두 생성자가 모두 생성된다?
소멸자의 실행 순서
	파생 클래스의 객체가 소멸될 때
		파생 클래스의 소멸자가 먼저 실행되고
		기본 클래스의 소멸자가 나중에 실행됨

컴파일러에 의해 묵시적으로 기본 클래스의 생성자를 선택하는 경우
	파생 클래스의 생성자에서 기본 클래스의 기본 생성자 호출
	컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하도록 컴파일함

기본 클래스에 기본 생성자가 없는 경우
	컴파일러가 B()에 대한 짝으로 A()를 찾을 수 없음
	컴파일 오류 발생

매개 변수를 가진 파생 클래스의 생성자는 묵시적으로 기본 클래스의 기본 생성자 선택
	파생 클래스의 매개 변수를 가진 생성자가 기본 클래스의 기본 생성자 호출
	컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하도록 컴파일함		

파생 클래스의 생성자에서 명시적으로 기본 클래스의 생성자 선택
	파생 클래스의 생성자가 명시적으로 기본 클래스의 생성자를 선택 호출함

컴파일러의 기본 생성자 호출 코드 삽입
	컴파일러가 묵시적으로 삽입한 코드를 확인할 수 있다

상속의 종류 - 상속 지정
	상송지정
		상속 선언시 public, private, protected의 3가지 중 하나 지정
		기본 클래스 멤버의 접근 속성을 어떻게 계승할지 지정
			public - 기본 클래스의 protected, public멤버 속성을 그대로 계승
			private - 기본 클래스의 protected, public멤버를 private로 계승
			protected - 기본 클래스의 protected, public멤버를 protected로 계승

상속 시 접근 지정에 따른 멤버의 접근 지정 속성 변화
	public 상속
	protected 상속
	private 상속 
		차이를 코드를 통해 확인

private 상속 사례 예제 8-4
	컴파일 오류나는 부분찾기 위 설명을 토대로 이해

protected 상속 사례
	컴파일 오류 나는 부분 이해

상속이 중첩될 때 접근 지정 사례
	중첩 상속에서의 접근 문제 이해

다중 상속
	기기의 컨버전스와 C++의 다중 상속
	여러가지 클래스로부터 상속

다중 상속 선언 및 멤버 호출
	class MusicPhone: public MP3, public MobilePhone { //다중 상속
	두 클래스의 기능을 모두 상속받아 사용가능
	
다중 상속의 문제점 - 기본 클래스 멤버의 중복 상속
	Base의 멤버가 이중으로 객체에 삽입되는 문젲ㅁ.
	동일한 x를 접근하는 프로그램이 서로 다른 x에 접근하는 결과를 낳게되어 잘못된 실행 오류가 
	발생

가상 상속
	다중 상속으로 인한 기본 클래스 멤버의 중복 상속 해결
	가상 상속
		파생 클래스의 선언문에서 기본 클래스 앞에 vitual로 선언
		파생 클래스의 객체가 생성될 때 기본 클래스의 멤버는 오직 한 번만 생성
			기본 클래스의 멤버가 중복하여 생성되는 것을 방지





























	
			






